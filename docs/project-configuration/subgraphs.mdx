---
sidebar_position: 5
sidebar_label: Subgraphs
description:
  "Explore Hasura's subgraphs functionality designed for multi-team projects. Understand the process of metadata object
  management, subgraph-specific guidelines, and data source ownership within Hasura. Discover how subgraphs facilitate
  efficient organization and controlled access to project metadata, enhancing team collaboration on Hasura projects."
keywords:
  - hasura
  - data source ownership
  - subgraphs
  - metadata management
  - multi-team projects
  - project management
  - hasura project structure
  - team collaboration
  - api management
  - application development
seoFrontMatterUpdated: true
---

# Subgraphs

## Introduction

A [**subgraph**](/project-configuration/subgraphs.mdx) is a way of organizing your data and allows you to connect
multiple data sources to your supergraph.

A project can have multiple subgraphs and the project metadata becomes the 'union' of the metadata across all subgraphs
of the project. Each subgraph can then be managed independently.

## What is a subgraph?

Subgraphs are used to maintain a logical separation of concerns and/or to allow different teams to work on different
parts of the supergraph at the same time without stepping on each other's toes.

Usually, a subgraph is "owned" and maintained by a team that is responsible for the data source, or more broadly:
"data domain", that it connects to. And by convention, one data domain is allocated to one subgraph.

A subgraph is analogous to a microservice owned by a particular team.

Subgraphs can reference each other, allowing, for example, the creation of relationships between them.

The supergraph is the composition of all subgraphs and their relationships, but it does not care how the metadata is
structured or organized into directories. That is up to the developer. The supergraph only cares that all metadata is
valid and can be compiled into an API build. The CLI and this documentation will suggest best practices for organizing
your metadata, but you can organize it however you choose.

Subgraphs have their own permission models and development lifecycles separate to that of the supergraph. They can be
developed, tested, and built independently while the supergraph guarantees the integrity of subgraph composition.
Meaning that the supergraph will only build, and generate an API if all subgraphs are in a valid state. In this Getting
Started section we propose best-practice for organizing your subgraphs, but it can be done however you choose.

A supergraph must have at least one subgraph, at least if you want it to do anything. ðŸ˜‰

## Naming

A good rule of thumb is to name your subgraphs after the a) the team responsible for it, b) the data domain it connects
to or for smaller projects, c) the data source which will be accessed in it.

Let's say we're in an organization and the data source we'll be connecting to is for customer profile data. The team
responsible for this data and some services related to it is called the "Customer Data" team. As such, we could create a
`customer_data_team` subgraph, reflecting the team's name, indicating that they're the ones who will be working on it.
Or, we could choose to be more specific and name it `customer_profile` to reflect the data domain itself, if multiple
teams are going to work on it.

Another example is, if we're working with a data source for a small project which we plan on using to contain all the
data for our whole project, and it's all in PostgreSQL, with some business logic in TypeScript, we could name it
`postgres_data` or `app` to keep it simple. This one subgraph would contain all the data domain specific metadata for
the whole project, at least for the time being.

## Subgraph context

Next, for convenience, we'll set the subgraph using the `context set` command in the CLI. This will simplify any
commands we use later on and save us from having to explicitly call out to which subgraph we're applying certain
actions.

```bash title="Run the following in your project, changing the directory to match where your subgraph.yaml is located:"
ddn context set subgraph ./my_subgraph/subgraph.yaml
```

### What did `context set subgraph` do?

This command simply updates a key-value pair in a context file in a project's `.hasura` folder to set your current
subgraph to whatever value you passed.

## Subgraph prefixes

To avoid collisions between GraphQL root fields and type names, you can optionally customize the prefixes for each
subgraph. For example, if two subgraphs both have a `Users` type, you can apply different prefixes to distinguish one
from the other. This ensures that each subgraph remains unique and prevents any naming conflicts.

You can make these modifications in the `subgraph.yaml` file for a subgraph.

```yaml title="Add the highlighted lines:"
kind: Subgraph
version: v2
definition:
  name: my_subgraph
  generator:
    rootPath: .
    #highlight-start
    graphqlRootFieldPrefix: my_subgraph_
    graphqlTypeNamePrefix: My_subgraph_
    #highlight-end
```

By default, the `subgraph.yaml` file is generated without any prefixes. You can read more about these fields
[here](supergraph-modeling/build-configs.mdx#subgraph-subgraphgeneratorconfig).

## Subgraph operations

### Initialize a new subgraph in a project directory

You can initialize a subgraph in your local project directory using the CLI by running:

```bash
ddn subgraph init <subgraph-name> --dir <path>
```

### Create a new subgraph on a Hasura DDN project

You can create a subgraph for a project on Hasura DDN using the CLI by running:

```bash
ddn project subgraph create <subgraph-name> --project <project-name>
```

### List all subgraphs of a Hasura DDN project

You can list all the subgraphs for a project using the CLI by running:

```bash
ddn project subgraph get --project <project-name>
```

### Delete a subgraph from a Hasura DDN project

You can delete a subgraph for a project using the CLI by running:

```bash
ddn project subgraph delete <subbgraph-name>  --project <project-name>
```


